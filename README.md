// I just implemented an API in this code. So what I did is, I created a router, the router is coming from gin and it's going to allow us to handle different routes. Now the route that I want to handle here is the /book, which means when I go to the localhost:8080/books, it's going to call the function getBooks(c *gin.Context), the gin context in this function is all the information about the request and it allows us to return a response. Here we've (c.IndentedJSON) and this means we will get a nicely formatted JSON with the proper indentation. The status code of this response that we're sending in this function is (StatusOK) And then what we're sending as the data is our books. Since I added the type book struct{which contains ID string, Title string, Author string and Quantity int}, The book struct can be serialized and we can also serialize a slice of the struct in (var books = []book). So we're going to return a JSON object that has all of these books in (var books = []book) from the function getBooks(c *gin.Context). Since we've router.GET("/books", getBooks), that means if we're sending a get request to this route, router.GET("/books", getBooks), then it will handle or call the function. However, if we send a post request, it's not going to handle that because the route says GET. Now in terms of running our router or running our web server, we can easily say router.run and put the IP address of where we want to get to. so in our case, we're doing localhost:8080. This is the basics for creating a very simple get request or a very simple get endpoint on our API. Again, the indent JSON gives us a nice JSON format which enables us to return files, return HTML, and all kinds of stuff. The http.StatusOK is coming from ("net/http") module. This is just going to 200. We need to first return a status response and then saying, what was the status of the request? which will be automatically serialized for us into JSON. Use this command to test the code (curl localhost:8080/books --include --header "Content-Type: application/json" -d @body.json --request "POST"),  where the header is "Content-Type: application/json, which defines the types of data that we're sending, -D stands for data, the @symbol means a file, like saying @body.json because it's the file that we want to use for the data. Then we specify the request type as a "POST" request and then send the request using curl. (curl localhost:8080/books), (curl localhost:8080/books/2), (curl localhost:8080/checkout?id=2 --request "PATCH"), Note that we can change the id, try the command with the id that doesn't exist as well as try it without the query parameter Id, as to get the quantity. (curl localhost:8080/return?id=3 --request "PATCH), we can also use this command the same as the checkout command. In recap, we've "GET" "POST", and "PATCH", and we've seen how to send JSON data, receive JSON data, serialize a struct, how to get the context, and how to return different status codes. We understand how to handle errors.
